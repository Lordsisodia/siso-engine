#!/usr/bin/env python3
"""
Task CLI - Command line interface for Legacy task management

Adapted from Blackbox5 Task Registry CLI
Works with our YAML/markdown task files
"""

import sys
import os
import yaml
import argparse
from pathlib import Path
from typing import List, Dict, Optional

# Add lib to path
sys.path.insert(0, str(Path(__file__).parent.parent / "lib"))

from state_machine import TaskStateMachine, TaskState, get_next_available_task


def get_autonomous_root() -> Path:
    """Find .Autonomous folder."""
    script_dir = Path(__file__).parent.parent
    return script_dir


def load_tasks() -> List[Dict]:
    """Load tasks from STATE.yaml."""
    autonomous_root = get_autonomous_root()
    state_file = autonomous_root.parent / "blackbox5" / "5-project-memory" / "siso-internal" / "STATE.yaml"

    if not state_file.exists():
        print(f"Error: STATE.yaml not found at {state_file}")
        return []

    try:
        with open(state_file) as f:
            content = f.read()
            # Extract YAML from markdown code block
            if "```yaml" in content:
                yaml_content = content.split("```yaml")[1].split("```")[0]
            else:
                yaml_content = content

            data = yaml.safe_load(yaml_content)
            return data.get("active_tasks", [])
    except Exception as e:
        print(f"Error loading tasks: {e}")
        return []


def load_legacy_tasks() -> List[Dict]:
    """Load tasks from Legacy tasks folder."""
    autonomous_root = get_autonomous_root()
    tasks_dir = autonomous_root / "tasks"

    tasks = []
    for task_file in tasks_dir.glob("TASK-*.md"):
        try:
            with open(task_file) as f:
                content = f.read()

            # Parse simple format
            task = {"id": task_file.stem, "file": str(task_file)}

            # Extract status
            if "**Status**:" in content:
                status_line = [l for l in content.split("\n") if "**Status**:" in l][0]
                if "pending" in status_line.lower():
                    task["status"] = "pending"
                elif "in_progress" in status_line.lower() or "in progress" in status_line.lower():
                    task["status"] = "in_progress"
                elif "completed" in status_line.lower():
                    task["status"] = "completed"
                else:
                    task["status"] = "pending"

            # Extract title
            if "**Task**:" in content:
                title_line = [l for l in content.split("\n") if "**Task**:" in l][0]
                task["name"] = title_line.split(":")[1].strip()
            else:
                task["name"] = task_file.stem

            tasks.append(task)
        except Exception:
            pass

    return tasks


def cmd_list(args):
    """List tasks."""
    tasks = load_legacy_tasks()

    if args.state:
        tasks = [t for t in tasks if t.get("status") == args.state]

    if not tasks:
        print("No tasks found.")
        return

    print(f"\n{'ID':<20} {'Status':<12} {'Title'}")
    print("-" * 60)

    for task in sorted(tasks, key=lambda x: x.get("status", "")):
        status = task.get("status", "unknown")
        icon = {
            "pending": "â³",
            "in_progress": "ğŸ”¨",
            "completed": "âœ…",
            "blocked": "ğŸš«"
        }.get(status, "â“")

        print(f"{task['id']:<20} {icon} {status:<10} {task.get('name', 'Untitled')}")

    print()


def cmd_what_can_i_do(args):
    """Show tasks that can be started."""
    tasks = load_legacy_tasks()

    # Filter pending tasks
    pending = [t for t in tasks if t.get("status") == "pending"]

    if not pending:
        print("\nNo available tasks. All tasks are either in progress or completed.\n")
        return

    print(f"\n{'Available Tasks (Ready to Start)'}")
    print("-" * 60)

    for task in pending:
        print(f"\n{task['id']}: {task.get('name', 'Untitled')}")
        print(f"  File: {task.get('file', 'N/A')}")

        # Show dependencies if any
        deps = task.get("dependencies", {}).get("requires", [])
        if deps:
            print(f"  Dependencies: {', '.join(deps)}")

    print(f"\nRun: ./bin/task take <task-id>\n")


def cmd_take(args):
    """Claim a task."""
    task_id = args.task_id

    # Find task file
    autonomous_root = get_autonomous_root()
    task_file = autonomous_root / "tasks" / f"{task_id}.md"

    if not task_file.exists():
        print(f"Error: Task {task_id} not found")
        return 1

    # Read and update
    try:
        with open(task_file) as f:
            content = f.read()

        # Update status
        if "**Status**:" in content:
            content = content.replace(
                "**Status**: â³ Pending",
                "**Status**: ğŸ”¨ In Progress"
            )
            content = content.replace(
                "**Status**: pending",
                "**Status**: in_progress"
            )

        with open(task_file, 'w') as f:
            f.write(content)

        print(f"âœ… Claimed {task_id}")
        print(f"   Status: in_progress")
        print(f"   File: {task_file}")

    except Exception as e:
        print(f"Error: {e}")
        return 1


def cmd_start(args):
    """Mark task as started."""
    return cmd_take(args)


def cmd_complete(args):
    """Mark task as completed."""
    task_id = args.task_id

    autonomous_root = get_autonomous_root()
    task_file = autonomous_root / "tasks" / f"{task_id}.md"

    if not task_file.exists():
        print(f"Error: Task {task_id} not found")
        return 1

    try:
        with open(task_file) as f:
            content = f.read()

        # Update status
        if "**Status**:" in content:
            content = content.replace(
                "**Status**: ğŸ”¨ In Progress",
                "**Status**: âœ… Completed"
            )
            content = content.replace(
                "**Status**: in_progress",
                "**Status**: completed"
            )

        with open(task_file, 'w') as f:
            f.write(content)

        print(f"âœ… Completed {task_id}")

    except Exception as e:
        print(f"Error: {e}")
        return 1


def cmd_status(args):
    """Show task details."""
    task_id = args.task_id

    autonomous_root = get_autonomous_root()
    task_file = autonomous_root / "tasks" / f"{task_id}.md"

    if not task_file.exists():
        print(f"Error: Task {task_id} not found")
        return 1

    try:
        with open(task_file) as f:
            content = f.read()

        print(f"\n{'='*60}")
        print(content)
        print(f"{'='*60}\n")

    except Exception as e:
        print(f"Error: {e}")
        return 1


def main():
    parser = argparse.ArgumentParser(
        description="Legacy Task Management CLI",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  ./bin/task list                    # List all tasks
  ./bin/task list --state pending    # List pending tasks
  ./bin/task what-can-i-do           # Show available tasks
  ./bin/task take TASK-001           # Claim a task
  ./bin/task complete TASK-001       # Mark task complete
  ./bin/task status TASK-001         # Show task details
        """
    )

    subparsers = parser.add_subparsers(dest="command", help="Commands")

    # list
    list_parser = subparsers.add_parser("list", help="List tasks")
    list_parser.add_argument("--state", help="Filter by state")

    # what-can-i-do
    subparsers.add_parser("what-can-i-do", help="Show available tasks")

    # take
    take_parser = subparsers.add_parser("take", help="Claim a task")
    take_parser.add_argument("task_id", help="Task ID")

    # start
    start_parser = subparsers.add_parser("start", help="Mark task as started")
    start_parser.add_argument("task_id", help="Task ID")

    # complete
    complete_parser = subparsers.add_parser("complete", help="Mark task as completed")
    complete_parser.add_argument("task_id", help="Task ID")

    # status
    status_parser = subparsers.add_parser("status", help="Show task details")
    status_parser.add_argument("task_id", help="Task ID")

    args = parser.parse_args()

    if not args.command:
        parser.print_help()
        return 1

    commands = {
        "list": cmd_list,
        "what-can-i-do": cmd_what_can_i_do,
        "take": cmd_take,
        "start": cmd_start,
        "complete": cmd_complete,
        "status": cmd_status,
    }

    cmd = commands.get(args.command)
    if cmd:
        return cmd(args) or 0
    else:
        parser.print_help()
        return 1


if __name__ == "__main__":
    sys.exit(main())
